import subprocess
import json
import time
import threading
import os
from datetime import datetime

class StreamManager:
    def __init__(self):
        self.streams = {}
        self.streams_file = "/flussonic/config/streams.json"
        self.load_streams()
        
    def load_streams(self):
        """تحميل قائمة البث"""
        if os.path.exists(self.streams_file):
            with open(self.streams_file, 'r') as f:
                self.streams = json.load(f)
        else:
            self.streams = {
                "streams": {},
                "channels": {},
                "vod": {}
            }
    
    def save_streams(self):
        """حفظ قائمة البث"""
        with open(self.streams_file, 'w') as f:
            json.dump(self.streams, f, indent=2)
    
    def add_stream(self, stream_id, stream_config):
        """إضافة بث جديد"""
        self.streams["streams"][stream_id] = {
            **stream_config,
            "status": "stopped",
            "created_at": datetime.now().isoformat(),
            "last_started": None,
            "restarts": 0
        }
        self.save_streams()
        return True
    
    def start_stream(self, stream_id):
        """بدء بث"""
        if stream_id not in self.streams["streams"]:
            return False
        
        stream = self.streams["streams"][stream_id]
        
        # بناء أمر FFmpeg
        cmd = self.build_ffmpeg_command(stream)
        
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                shell=True
            )
            
            self.streams["streams"][stream_id].update({
                "status": "running",
                "pid": process.pid,
                "last_started": datetime.now().isoformat(),
                "process": process
            })
            
            # بدء مراقبة البث
            monitor_thread = threading.Thread(
                target=self.monitor_stream,
                args=(stream_id, process)
            )
            monitor_thread.daemon = True
            monitor_thread.start()
            
            self.save_streams()
            return True
            
        except Exception as e:
            print(f"Error starting stream {stream_id}: {e}")
            return False
    
    def build_ffmpeg_command(self, stream):
        """بناء أمر FFmpeg"""
        input_source = stream.get("source")
        output_format = stream.get("format", "hls")
        
        cmd = ["ffmpeg", "-i", input_source]
        
        # إعدادات الفيديو
        if "video_codec" in stream:
            cmd.extend(["-c:v", stream["video_codec"]])
        else:
            cmd.extend(["-c:v", "copy"])
        
        # إعدادات الصوت
        if "audio_codec" in stream:
            cmd.extend(["-c:a", stream["audio_codec"]])
        else:
            cmd.extend(["-c:a", "copy"])
        
        # تنسيق الإخراج
        if output_format == "hls":
            hls_time = stream.get("hls_time", 2)
            hls_list_size = stream.get("hls_list_size", 5)
            output_path = f"/flussonic/streams/{stream['id']}/playlist.m3u8"
            
            cmd.extend([
                "-f", "hls",
                "-hls_time", str(hls_time),
                "-hls_list_size", str(hls_list_size),
                "-hls_flags", "delete_segments",
                output_path
            ])
        
        elif output_format == "rtmp":
            rtmp_url = stream.get("rtmp_url", "rtmp://localhost/live")
            cmd.extend(["-f", "flv", f"{rtmp_url}/{stream['id']}"])
        
        return " ".join(cmd)
    
    def monitor_stream(self, stream_id, process):
        """مراقبة البث"""
        while process.poll() is None:
            time.sleep(5)
        
        # إعادة التشغيل التلقائي
        if stream_id in self.streams["streams"]:
            stream = self.streams["streams"][stream_id]
            restarts = stream.get("restarts", 0)
            
            if restarts < 3:  # 3 محاولات إعادة تشغيل
                stream["restarts"] = restarts + 1
                print(f"Restarting stream {stream_id} (attempt {restarts + 1})")
                time.sleep(2)
                self.start_stream(stream_id)
            else:
                stream["status"] = "failed"
                self.save_streams()
    
    def get_stream_status(self, stream_id=None):
        """الحصول على حالة البث"""
        if stream_id:
            return self.streams["streams"].get(stream_id, {})
        return self.streams["streams"]
    
    def generate_m3u(self, username, password):
        """إنشاء قائمة M3U"""
        m3u_content = "#EXTM3U\n"
        m3u_content += "# Generated by Flussonic-like IPTV\n"
        m3u_content += f"# Date: {datetime.now()}\n\n"
        
        for stream_id, stream in self.streams["streams"].items():
            if stream.get("status") == "running":
                # معلومات القناة
                m3u_content += f'#EXTINF:-1 tvg-id="{stream_id}" tvg-name="{stream["name"]}" '
                m3u_content += f'group-title="{stream.get("category", "General")}",{stream["name"]}\n'
                
                # رابط البث
                if stream.get("format") == "hls":
                    m3u_content += f'http://localhost/streams/{stream_id}/playlist.m3u8\n'
                else:
                    m3u_content += f'http://localhost/live/{username}/{password}/{stream_id}\n'
        
        return m3u_content
    
    def generate_xtream_url(self, username, password, stream_id):
        """إنشاء رابط Xtream Codes"""
        return f"http://localhost:25462/live/{username}/{password}/{stream_id}.ts"
